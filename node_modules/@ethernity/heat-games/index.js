/**
 * Heat Games SDK
 * Ethernity.live
 * 2020
 *
 * Interface to heat-sdk with functions for gaming
 * Both for frontend and backend
 *
 */
'use strict';

const heatsdk = require('heat-sdk');
const crypto = require('crypto');

const HeatConfig = new heatsdk.Configuration({isTestnet: true})
var HeatSDK = new heatsdk.HeatSDK(HeatConfig)


exports.Config = function(args) {
  HeatConfig.isTestnet = !!args.isTestnet
}


/** Make move
 *
 * @card      name of the card played
 * @secret    secret to sign the transaction
 * @opponent  opponent's account id
 * ========================================================================== 
 */
exports.makeMove = async function({
      card,
      secret,
      opponent
    }) {

    let messageArgs = {
      message: card,
      fee: 1000000,
      deadline: 1440,
	    secretPhrase: secret,
      recipient: opponent,
    }

    try {
  		return await HeatSDK.api.post('/tx/sendmessage', messageArgs)
  	} catch (e) {
  		return e
  	}
}


/** Send money
 *
 * @amount    amount to send
 * @secret    secret to sign the transaction
 * @recipient receiver's account id
 * @message   message to send
 * ========================================================================== 
 */
exports.sendMoney = async function({
      amount,
      secret,
      recipient,
      message
    }) {

    let txArgs = {
      amount,
      fee: 1000000,
      deadline: 1440,
      secretPhrase: secret,
      message,
      recipient
    }

    try {
  		return await HeatSDK.api.post('/tx/sendmoney', txArgs)
  	} catch (e) {
  		return e
  	}

}

/** Send encrypted message with a password to a player
*
* @param recipient  recipient id
* @param secret     secret to sign the message
* @param message    message to send
* ==========================================================================
*/
exports.sendPassword = async function({
  recipient,
  secret,
  message
}) {

  const txArgs = {
      messageToEncrypt: message,
      fee: 1000000,
      deadline: 1440,
      recipient: recipient,
      secretPhrase: secret,
  }

  try {
    return await HeatSDK.api.post('/tx/sendmessage', txArgs)
  } catch (e) {
    return e
  }
}

/** Subscribe to messages
*
* @param type       type of subscription (by now only 'messages')
* @param cb         callback function to be executed
* ==========================================================================
*/
exports.subscribe = function(type, cb) {
  if (type === 'messages') {
    const sub = HeatSDK.subscriber.message({})
    return sub.onMessage(cb)
  }
  return null
}


/** Read message, both plain text or encrypted
*
* @param m       message object from subscription
* @param secret  recipient's secret, to decrypt the message (if needed)
* ==========================================================================
*/
exports.readMessage = async function(m, secret) {
  let message
  if ( m.messageIsEncrypted ) {
    let data = await exports.decryptMessage(m, secret)
    message = data.message
  } else {
    message = exports.hex2a(m.messageBytes)
  }
  return message
}


/** Decrypt message
*
* @param m       message object from subscription
* @param secret  recipient's secret, to decrypt the message (if needed)
* ==========================================================================
*/
exports.decryptMessage = async function(m, secret) {
  try {
    return await HeatSDK.api.get(`/tools/aes/decryptMessageBytes/${m.messageBytes}/${m.recipientPublicKey}/${secret}`)
  } catch(e) {
    return e
  }
}


/** Get account number by secret
*
* @param secret  account secret
* ==========================================================================
*/
exports.getAccountBySecret = async function(secret) {
  try {
      return await HeatSDK.api.get(`/account/find/secretphrase/${secret}`)
  } catch (e) {
    return e
  }
}

/** Get account by id
*
* @param id  account id
* ==========================================================================
*/
exports.getAccountById = async function(id) {
  try {
      return await HeatSDK.api.get(`/account/find/${id}`)
  } catch (e) {
    return e
  }
}


/** Helpers
*
* ==========================================================================
*/

exports.hex2a = function(hex) {
  var str = '';
  for (var i = 0; i < hex.length; i += 2) str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  return str;
}

exports.aesEncrypt = function (text, password) {
  const cipher = crypto.createCipher('AES-128-CBC', password)
  let message = cipher.update(text,'utf8','hex')
  message += cipher.final('hex')
  return message
}

exports.aesDecrypt = function (encrypted, password) {
  const decipher = crypto.createDecipher('AES-128-CBC', password)
  let message = decipher.update(encrypted,'hex','utf8')
  message += decipher.final('utf8')
  return message
}



